---
layout: post
title: 6 Months with Kotlin
date: 2025-11-04 19:04:00
categories: [Backend, Kotlin]
tags: [kotlin, from java to kotlin]
---

# My Kotlin Journey: 6 Months of Discovery

Six months ago, when I started a new job, Kotlin became my daily companion. As a Java guy, I thought, “How different can it really be?” Well… Kotlin had a few surprises in store that made me excited, and occasionally jealous that Java didn’t think of them first.

Here’s my personal take on what I’ve learned, what I love, and a few quirks that kept me on my toes.

## 1. Less Boilerplate, More Coffee ☕️

One of the first things I noticed was how Kotlin drastically reduces boilerplate. 

Data classes are a game-changer. Writing `equals()`, `hashCode()`, and `toString()` manually in Java used to feel like a repetitive warm-up exercise — now Kotlin does it all in a single line (although with Java 21+, `records` get pretty close!).

```kotlin
data class User(val id: Int, val name: String)
```

While Java `records` enforce immutability, the Kotlin `data class` takes it a step further by automatically generating a `copy()` method, which is invaluable for working with immutable objects in a functional style. Simple and clean!

## 2. Null Safety is Life

Null pointer exceptions—Java’s infamous gift to programmers. Kotlin practically hugs you and says, “Not today, buddy!” 

With nullable types and the safe-call operator (`?.`), I find myself avoiding the dreaded `NullPointerException` more than ever.

```kotlin
val name: String? = user?.name
```

The real power move is combining it with the Elvis operator (`?:`) to provide a clean fallback value.

```kotlin
val nameLength: Int = user?.name?.length ?: 0 
// If user or name is null, nameLength is safely defaulted to 0.
```

It’s simple, readable, and makes me feel like my code is safer. Java still doesn’t have this built-in, so Kotlin wins here hands down.

<div style="width:100%;height:0;padding-bottom:56%;position:relative;"><iframe src="https://giphy.com/embed/3oz8xUJsD8AsihJrtC" width="100%" height="100%" style="position:absolute" frameBorder="0" class="giphy-embed" allowFullScreen></iframe></div><p><a href="https://giphy.com/gifs/mylabbox-safety-safe-3oz8xUJsD8AsihJrtC">via GIPHY</a></p>

## 3. Companion Objects and Utility Keywords

Kotlin introduces some concepts and keywords that make life a lot easier for developers.

* Companion Objects – a neat way to add static-like behavior to a class:

```kotlin
class User(val id: Int, val name: String) {
    companion object Factory {
        fun createDefault() = User(0, "Default")
    }
}
```

_Technically, a companion object is a singleton object instance inside the class, which is how it provides this static-like access, distinct from Java's true `static` fields._

* `Reified` – allows type checks and casts inside inline functions, something Java can’t do without reflection:

```kotlin
inline fun <reified T> isOfType(obj: Any) = obj is T
```

* Scope functions – `let`, `run`, `also`, `takeIf`, etc., make code more concise and readable:

```kotlin
val length = "Hello".let { it.length }
val upper = "Hello".run { this.uppercase() }
val user = User(1, "Alice").also { println(it) }
val number = 42.takeIf { it > 10 }
```

* Error handling utilities – `runCatching` and `recoverCatching` simplify exception handling in a functional style:

```kotlin
fun parseDate(input: String): LocalDate {
  val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")

  return runCatching {
    LocalDate.parse(input, formatter)
  }.recoverCatching {
    // if parsing fails -> fallback
    LocalDate.now()
  }.getOrThrow() // return final value or throw if both failed
}
```

## 4. Extension Functions: Add Powers to Existing Classes

Java doesn’t let you just add a function to an existing class. Kotlin does, and I’m in love with it.

```kotlin
fun String.shout() = this.uppercase() + "!!!"
println("hello".shout()) // HELLO!!!
```

It’s like giving your classes a caffeine boost—suddenly they can do things they couldn’t before, without inheritance or messy utility classes. 

You can now call `"hello".shout()` as if `shout()` was part of `String`. No inheritance or subclassing needed.

## 5. Concise Collections API

Kotlin’s standard library makes working with collections elegant. Functions like `map`, `filter`, `flatMap`, and `groupBy` feel intuitive. Coming from Java streams, it’s familiar yet cleaner.

```kotlin
val numbers = listOf(1, 2, 3, 4)
val doubled = numbers.map { it * 2 } // [2, 4, 6, 8]
```

Readable, expressive, and enjoyable—finally, code that feels like it’s written for humans.

## A Note on Concurrency

I would also like to mention Coroutines here, but that’s a topic big enough for a separate article itself!

## My Observations

* Kotlin makes me feel productive. Less boilerplate, smart language features, and expressive syntax save time.
* It encourages safer code. Null safety, immutable data structures, and a strong type system reduce bugs.
* There’s a learning curve. Some syntax and functional paradigms take time to internalize, but it’s worth it.

In these six months, I’ve gone from curious observer to someone who prefers Kotlin for new backend projects.

If you’re coming from Java, my advice is simple: embrace Kotlin’s features gradually, experiment with small projects, and don’t fight the language—it has your back.

In the end, Java might still be your trusty coding buddy, or Kotlin could steal the spotlight, it’s up to you.

<div style="width:100%;height:0;padding-bottom:56%;position:relative;"><iframe src="https://giphy.com/embed/TC4gO8Q26PkEdJJGDp" width="100%" height="100%" style="position:absolute" frameBorder="0" class="giphy-embed" allowFullScreen></iframe></div><p><a href="https://giphy.com/gifs/foilarmsandhog-foil-arms-and-hog-fah-conor-mckenna-TC4gO8Q26PkEdJJGDp">via GIPHY</a></p>

Whatever you choose, enjoy the ride and happy coding.

Cheers
